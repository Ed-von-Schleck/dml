This document describes the usage of the dml command line tool as well as the
syntax of dml files.

Usage
=====

If you type 'dml --help' on the command line, you should see something like
that:

Usage: dml [options] FILE

Options:
  -h, --help   show this help message and exit
  -t, --html   generates HTML output
  -d, --dml    generates DML output
  -b, --debug  generates debug output
  -q, --quiet  don't print status messages to stdout

FILE must be a valid dml-file. The next section describes the syntax of it. If
that file does not exist, dml with print an Error and exit.

The options might differ if you have other backends installed. What is always
there is '-q' or '--quiet', which supresses output in the console, and '-h' or
'--help' to show the help.

Any other option controls the various ouptuts. Each will write a file in the
working directory with the filename (without the '.dml' extension) + the
backend extension. For example:

$ dml --html path/to/my_funny_play.dml

will write a 'my_funny_play.html' into your current directory. Any existing
file named 'my_funny_play.html' in this directory will be overwritten.


Backends
--------

There are two kinds of backends: sinks and postprocessors. It's not too
difficult to write new backends; please consult the developers documentation if
you inted to do so.

Sinks directly feed off the parser (they are called sinks because it's a
streaming parser, and every event generated in the parser will eventually land
there, but they themselves don't generate or forward any event. They are the
end of the event food chain). They don't require third party tools to be
installed manually.

Sinks that come with dml:
 * debug: usefull for introspection if something goes wrong or when writing a
   new sink
 * dml: transforms the dml into another dml. Yeah. Really.
 * html: outputs a valid xhtml file to be
 * latex: writes a nice latex file for further processing
 * pdf: native pdf output, see e.g. LaTeX2pdf for a postprocessor outputting
   pretty pdfs

Postprocessors don't recieve any events from anything at all, they rely on
a sink to have done the dirty work. They just transform the output of a sink
into something else (usually a pdf). So you might have a LaTeX sink and a
LaTeX2pdf postprocessor, or a html sink and a html2pdf postprocessor. Post-
processors usually have a '2' in their name to indicate where they get their
source from. If a postprocessor is selected, it will automatically activate
it's corresponding sink, whether you selected it or not. Postprocessors usually
require a third party tool (like LaTeX). These tools may not be
automatically installed if you install dml. Refer to the READMEs in the 
'postprocessors' folder for installation help.

Postprocessors that come with dml:
 * latex2pdf: like it says. Takes latex and boom! - pdf. Magic. Pure magic.

dml Syntax
==========

For a for more scientific explanation, look at the BNF part below.


General Syntax
--------------

The dml is structured like a play usually is: First comes a title, then maybe a
text block for subtitle or abstract, then a number of informations like author,
date etc. The syntax for that is easy, like that:

= My Funny Play =

it's so funny

    author: me
    date: 03/04/2010
    
OK, that's:
 * title separated with "="
 * title, block and tag/value pairs separated by two newlines
 * tag/value lines indented
 * a tag/value line without a ":" will be treated as a tag, not a value
The indentation can either be tab or whitespace.

Next may come the cast of the play. It may look like that:

== Persons Involved ==

    me: the funny author
    you: the bored reader
    the open source community

En detail:
 * cast title separated with "=="
 * title, block and actor declaration/definition pairs separated by two newlines
 * declaration/definition lines indented
 * a declaration/definition line without a ":" will be treated as a declaration,
   not a definition
Sounds familiar? Yes, the syntax is the same, it just means something different.

OK, a play needs some content, starting with an act title. Lo and behold:

=== ACT I ===

it was a dark and stormy night.

    me: see? <smiles and waves> It's easy!
    you: OK ...
    
=== ACT II ===

    you: I'm gonna go. Now. <off>

The author stands alone on the stage.

    me: Well then ... good bye!
    the open source community: <is not very interested>
    
OK, I guess it's clear what it means. The only new thing are inline stage
direction enclosed with '<' and '>'.

How all of this will eventually be displayed is up to the backend.


Functions
---------
At any time you might write a function, starting with '@', followerd by a
function name and then a function block delimited by '{' and '}'. Here's
what they do:

 -- meta:
Used to declare metadata in key/value pairs. Only useful in the header of
the dml file. For example:

@meta {
table_of_contents: True
}

 -- include:
Include the contents of another dml-file in your play. Example:

@include{ a_part_of_a_play.dml }

The file to be included must be in the directory of the parent file or in
your working (current) directory.


Syntax in BNF
-------------

My BNF foo is getting a bit rusty, please report any error you see here. I expect
pretty obvios one. This is the syntax as I believe it to be:

DML             ::= FUNCTION | TITLE | CAST | ACT | BLOCK | LINE | KEY | VALUE
FUNCTION        ::= "@" WORD "{" FUNCTION_BODY "}"
TITLE           ::= NEWLINE+ "=" WORD* "="
CAST            ::= NEWLINE+ "==" WORD* "=="
ACT             ::= NEWLINE+ "===" WORD* "==="
BLOCK           ::= NEW_PARAGRAPH ( WORD | NEWLINE WORD)*
LINE            ::= NEWLINE KEY VALUE
KEY             ::= ( WHITESPACE | TAB ) WORD* ( ":" | NEWLINE)
VALUE           ::= WORD ( WORD | NEWLINE WORD)*
NEW_PARAGRAPH   ::= NEWLINE NEWLINE+
NEWLINE         ::= "\n"
WHITESPACE      ::= " "
TAB             ::= "\n"
WORD            ::= <letters, numbers, stuff like that>
FUNCTION_BODY   ::= <that's up to the function>

Please note that my lexer ignores whitespace and tabs except after newlines,
so the BNF up there is neither entirely correct, nor is it actually used to
implement the parser.
