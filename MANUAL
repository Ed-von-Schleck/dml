This document describes the usage of the dml command line tool as well as the
syntax of dml files.

Usage
=====

If you type 'dml' on the commandline, you should see something like that:

Usage: dml [options] FILE

Options:
  -h, --help   show this help message and exit
  -t, --html   generates HTML output
  -d, --dml    generates DML output
  -b, --debug  generates debug output
  -q, --quiet  don't print status messages to stdout

FILE must be a valid dml-file. The next section describes the syntax of it. If
that file does not exist, dml with print an Error and exit.

The options might differ if you have other backends installed. What is always
there is -q, which supresses output in the console, and -h to show the help.

Any other option controls the various ouptuts. Each will write a file in the
working directory with the filename (without the '.dml' extension) + the
backend extension. For example:

$ dml --html path/to/my_funny_play.dml

will write a 'my_funny_play.html' into your current directory. Any existing
file named 'my_funny_play.html' will be overwritten.

dml Syntax
==========

For a for more systematic explanation, look at the BNF part below.

General Syntax
--------------

The dml is structured like a play usually is: First comes a title, then maybe a
text block for subtitle or abstract, then a number of informations like author,
date etc. The syntax for that is easy, like that:

= My Funny Play =

it's so funny

    author: me
    date: 03/04/2010
    
That is:
 * title separated with "="
 * title, block and tag/value pairs separated by two newlines
 * tag/value lines indented
 * a tag/value line without a ":" will be treated as a tag, not a value
The indentation can either be tab or whitespace.

Next may come the cast of the play. It may look like that:

== Persons Involved ==

    me: the funny author
    you: the bored reader
    the open source community

En detail:
 * cast title separated with "=="
 * title, block and actor declaration/definition pairs separated by two newlines
 * declaration/definition lines indented
 * a declaration/definition line without a ":" will be treated as a declaration,
   not a definition
Sounds familiar? Yes, the syntax is the same, it just means something different.

OK, a play needs some content, starting with an act title. Lo and behold:

=== ACT I ===

it was a dark and stormy night.

    me: see? <smiles and waves> It's easy!
    you: OK ...
    
=== ACT II ===

    you: I'm gonna go. Now. <off>

The author stands alone on the stage.

    me: Well then ... good bye!
    the open source community: <is not very interested>
    
OK, I guess it's clear what it means. The only new thing are inline stage
direction enclosed with '<' and '>'.

How all of this will eventually be displayed is up to the backend.

Functions
---------
At any time you might write a function, starting with '@', followerd by a
function name and then a function block delimited by '{' and '}'. Here's
what they do:

 -- meta:
Used to declare metadata in key/value pairs. For example:

@meta {
table_of_contents: True
}

 -- include:
Include the contents of another dml-file in your play. Example:

@include{ a_part_of_a_play.dml }

The file to be included must be in the directory of the parent file or in
your working (current) directory.
BNF
---

My BNF knowledge is getting a bit rusty, please report any error you see here.
This is the syntax as I believe it to be:

DML             ::= FUNCTION | TITLE | CAST | ACT | BLOCK | LINE | KEY | VALUE
FUNCTION        ::= "@" WORD "{" FUNCTION_BODY "}"
TITLE           ::= NEWLINE+ "=" WORD* "="
CAST            ::= NEWLINE+ "==" WORD* "=="
ACT             ::= NEWLINE+ "===" WORD* "==="
BLOCK           ::= NEW_PARAGRAPH ( WORD | NEWLINE WORD)*
LINE            ::= NEWLINE KEY VALUE
KEY             ::= ( WHITESPACE | TAB ) WORD* ( ":" | NEWLINE)
VALUE           ::= WORD ( WORD | NEWLINE WORD)*
NEW_PARAGRAPH   ::= NEWLINE NEWLINE+
NEWLINE         ::= "\n"
WHITESPACE      ::= " "
TAB             ::= "\n"
WORD            ::= <letters, numbers, stuff like that>
FUNCTION_BODY   ::= <that's up to the function>

Please note that my lexer ignores whitespace and tabs except after newlines,
so the BNF up there is not entirely correct, nor is it actually used to
implement the parser.
